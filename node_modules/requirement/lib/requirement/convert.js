// Generated by CoffeeScript 1.9.3
(function() {
  var Coffee, Tree, _, fs, js2coffee, path;

  _ = require("lodash");

  Coffee = require("coffee-script");

  js2coffee = require("js2coffee");

  fs = require("fs");

  path = require("path");

  Tree = require("./tree");

  module.exports = (function() {
    function _Class(arg) {
      var dir, fn, j, len, ref;
      this.paths = arg.paths;
      ref = this.paths;
      fn = (function(_this) {
        return function(dir) {
          return _this.convert(dir);
        };
      })(this);
      for (j = 0, len = ref.length; j < len; j++) {
        dir = ref[j];
        fn(dir);
      }
    }

    _Class.prototype.convert = function(dir, root) {
      var files;
      if (root == null) {
        root = dir;
      }
      dir = path.resolve(dir);
      files = fs.readdirSync(dir);
      return files.forEach((function(_this) {
        return function(file) {
          var coffee, current, fpath, index, matches, regex, requires;
          fpath = path.join(dir, file);
          if (fs.lstatSync(fpath).isDirectory()) {
            return _this.convert(fpath, root);
          } else {
            regex = /[A-Z]\w+\s+=((\s+[A-Z]\w+:){1,}\s+require\s+["\w\.\/]+){1,}/gm;
            file = fs.readFileSync(fpath).toString();
            matches = file.match(regex) || [];
            current = matches.map(function(match) {
              var obj;
              match = match.replace(/require/g, "");
              match = match.replace(/\s+=/g, ":");
              return obj = Coffee["eval"](match);
            });
            current = _.merge.apply(_, current);
            console.log("current", current);
            if (current) {
              requires = _this.buildRequires(root, fpath, current);
              requires = JSON.stringify(requires).replace(/\"([^(\")"]+)\":/g, "$1:");
              coffee = js2coffee.build("x = " + requires);
              coffee = coffee.code.replace("x = ", "");
              coffee = coffee.replace(/: '/g, ": require '");
              console.log("coffee", coffee);
              index = 0;
              return file = file.replace(regex, function(match) {
                if (index === 0) {
                  return coffee;
                } else {
                  return "";
                }
              });
            }
          }
        };
      })(this));
    };

    _Class.prototype.buildRequires = function(dir, fpath, current, future) {
      var abs, classes, key, last, value;
      if (future == null) {
        future = {};
      }
      for (key in current) {
        value = current[key];
        if (value instanceof Object) {
          this.buildRequires(dir, fpath, value, future);
        } else {
          abs = path.join(path.dirname(fpath), value);
          abs = abs.replace(dir + "/", '');
          classes = this.pathToClasses(abs);
          last = future;
          classes.forEach(function(item, i) {
            if (i === classes.length - 1) {
              return last[item] = value;
            } else {
              last[item] || (last[item] = {});
              return last = last[item];
            }
          });
        }
      }
      return future;
    };

    _Class.prototype.classify = function(string) {
      var regex;
      regex = /^[a-z]|[_\.][a-z]/g;
      return string.replace(regex, function(match) {
        return match.toUpperCase().replace(/_/, "");
      });
    };

    _Class.prototype.pathToClasses = function(path) {
      var classes, j, klass, len, ref;
      path = path.replace(/\//g, ".");
      classes = [];
      ref = path.split(".");
      for (j = 0, len = ref.length; j < len; j++) {
        klass = ref[j];
        klass = this.classify(klass);
        if (classes.indexOf(klass) === -1) {
          classes.push(klass);
        }
      }
      return classes;
    };

    return _Class;

  })();

}).call(this);
